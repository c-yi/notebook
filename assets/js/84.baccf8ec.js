(window.webpackJsonp=window.webpackJsonp||[]).push([[84],{488:function(t,v,_){"use strict";_.r(v);var e=_(23),r=Object(e.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"设计模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#设计模式"}},[t._v("#")]),t._v(" 设计模式")]),t._v(" "),_("div",{staticClass:"custom-block tip"},[_("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),_("p",[t._v("来自 "),_("a",{attrs:{href:"http://www.baidu.com",target:"_blank",rel:"noopener noreferrer"}},[t._v("菜鸟教程"),_("OutboundLink")],1)])]),t._v(" "),_("p",[t._v("设计模式的应用")]),t._v(" "),_("blockquote",[_("p",[t._v("面相对象(OO) => 功能模块[设计模式+算法(数据结构)] => 框架[使用多种设计模式] => 架构[服务器集群]")])]),t._v(" "),_("p",[_("strong",[t._v("代码重用性")]),t._v(" (即:相同功能的代码,不用多次编写)"),_("br"),t._v(" "),_("strong",[t._v("可读性")]),t._v(" (即:编程规范性,便于其他程序员的阅读和理解)"),_("br"),t._v(" "),_("strong",[t._v("可扩展性")]),t._v(" (即:当需要增加新的功能时,非常的方便,称为可维护性"),_("br"),t._v(" "),_("strong",[t._v("可靠性")]),t._v(" (即:当我们增加新的功能后,对原来的功能没有影响"),_("br"),t._v("\n使程序呈现 "),_("strong",[t._v("高内聚,低耦合")]),t._v(" 的特性")]),t._v(" "),_("h2",{attrs:{id:"设计模式类型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#设计模式类型"}},[t._v("#")]),t._v(" 设计模式类型")]),t._v(" "),_("ol",[_("li",[t._v("创建型模式")])]),t._v(" "),_("blockquote",[_("p",[t._v("这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式,而不是使用 new 运算符直接实例化对象"),_("br"),t._v("\n这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。")])]),t._v(" "),_("ul",[_("li",[t._v("工厂模式（Factory Pattern）")]),t._v(" "),_("li",[t._v("抽象工厂模式（Abstract Factory Pattern）")]),t._v(" "),_("li",[t._v("单例模式（Singleton Pattern）")]),t._v(" "),_("li",[t._v("建造者模式（Builder Pattern）")]),t._v(" "),_("li",[t._v("原型模式（Prototype Pattern）")])]),t._v(" "),_("ol",{attrs:{start:"2"}},[_("li",[t._v("结构型模式")])]),t._v(" "),_("blockquote",[_("p",[t._v("这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。")])]),t._v(" "),_("ul",[_("li",[t._v("适配器模式（Adapter Pattern）")]),t._v(" "),_("li",[t._v("桥接模式（Bridge Pattern）")]),t._v(" "),_("li",[t._v("过滤器模式（Filter、Criteria Pattern）")]),t._v(" "),_("li",[t._v("组合模式（Composite Pattern）")]),t._v(" "),_("li",[t._v("装饰器模式（Decorator Pattern）")]),t._v(" "),_("li",[t._v("外观模式（Facade Pattern）")]),t._v(" "),_("li",[t._v("享元模式（Flyweight Pattern）")]),t._v(" "),_("li",[t._v("代理模式（Proxy Pattern）")])]),t._v(" "),_("ol",{attrs:{start:"3"}},[_("li",[t._v("行为型模式")])]),t._v(" "),_("blockquote",[_("p",[t._v("这些设计模式特别关注对象之间的通信。")])]),t._v(" "),_("ul",[_("li",[t._v("责任链模式（Chain of Responsibility Pattern）")]),t._v(" "),_("li",[t._v("命令模式（Command Pattern）")]),t._v(" "),_("li",[t._v("解释器模式（Interpreter Pattern）")]),t._v(" "),_("li",[t._v("迭代器模式（Iterator Pattern）")]),t._v(" "),_("li",[t._v("中介者模式（Mediator Pattern）")]),t._v(" "),_("li",[t._v("备忘录模式（Memento Pattern）")]),t._v(" "),_("li",[t._v("观察者模式（Observer Pattern）")]),t._v(" "),_("li",[t._v("状态模式（State Pattern）")]),t._v(" "),_("li",[t._v("空对象模式（Null Object Pattern）")]),t._v(" "),_("li",[t._v("策略模式（Strategy Pattern）")]),t._v(" "),_("li",[t._v("模板模式（Template Pattern）")]),t._v(" "),_("li",[t._v("访问者模式（Visitor Pattern）")])]),t._v(" "),_("ol",{attrs:{start:"4"}},[_("li",[t._v("J2EE 模式")])]),t._v(" "),_("blockquote",[_("p",[t._v("这些设计模式特别关注表示层。这些模式是由 Sun Java Center 鉴定的。")])]),t._v(" "),_("ul",[_("li",[t._v("MVC 模式（MVC Pattern）")]),t._v(" "),_("li",[t._v("业务代表模式（Business Delegate Pattern）")]),t._v(" "),_("li",[t._v("组合实体模式（Composite Entity Pattern）")]),t._v(" "),_("li",[t._v("数据访问对象模式（Data Access Object Pattern）")]),t._v(" "),_("li",[t._v("前端控制器模式（Front Controller Pattern）")]),t._v(" "),_("li",[t._v("拦截过滤器模式（Intercepting Filter Pattern）")]),t._v(" "),_("li",[t._v("服务定位器模式（Service Locator Pattern）")]),t._v(" "),_("li",[t._v("传输对象模式（Transfer Object Pattern）")])]),t._v(" "),_("h2",{attrs:{id:"设计模式的六大原则"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#设计模式的六大原则"}},[t._v("#")]),t._v(" 设计模式的六大原则")]),t._v(" "),_("ol",[_("li",[_("p",[t._v("单一职责")]),t._v(" "),_("ul",[_("li",[t._v("一个类应该只负责一项职责")]),t._v(" "),_("li",[t._v("降低类的复杂度,一个类只负责一项职责")]),t._v(" "),_("li",[t._v("提高类的可读性,可维护性")]),t._v(" "),_("li",[t._v("降低变更引起的风险")]),t._v(" "),_("li",[t._v("只有逻辑足够简单是才可以在代码级别违反单一职责原则;只有类中的方法足够少,才可以在方法级别保持单一原则")])])]),t._v(" "),_("li",[_("p",[t._v("接口隔离原则（Interface Segregation Principle)")]),t._v(" "),_("p",[t._v("这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。")]),t._v(" "),_("p",[t._v("它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。")])]),t._v(" "),_("li",[_("p",[t._v("依赖倒转原则（Dependence Inversion Principle）")]),t._v(" "),_("p",[t._v("这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。")])]),t._v(" "),_("li",[_("p",[t._v("里氏代换原则（Liskov Substitution Principle）")]),t._v(" "),_("blockquote",[_("p",[t._v("将父类和子类都继承一个更通俗的类,原有的继承关系去掉,代用依赖,聚合,组合,等关系代替")])]),t._v(" "),_("p",[t._v("里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。")])]),t._v(" "),_("li",[_("p",[t._v("开闭原则（Open Close Principle）")]),t._v(" "),_("p",[t._v("开闭原则的意思是：**对扩展开放，对修改关闭。**在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。")])]),t._v(" "),_("li",[_("p",[t._v("迪米特法则，又称最少知道原则（Demeter Principle）")]),t._v(" "),_("p",[t._v("最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。")])]),t._v(" "),_("li",[_("p",[t._v("合成复用原则（Composite Reuse Principle）")]),t._v(" "),_("p",[t._v("合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。")])])])])}),[],!1,null,null,null);v.default=r.exports}}]);