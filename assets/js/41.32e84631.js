(window.webpackJsonp=window.webpackJsonp||[]).push([[41],{410:function(v,_,t){"use strict";t.r(_);var a=t(23),l=Object(a.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"设计表"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#设计表"}},[v._v("#")]),v._v(" 设计表")]),v._v(" "),t("h2",{attrs:{id:"三大范式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#三大范式"}},[v._v("#")]),v._v(" 三大范式")]),v._v(" "),t("p",[v._v("范式是一种数学理论,在关系型数据库上用来减少数据冗余")]),v._v(" "),t("p",[v._v("满足的范式越多,越符合高标准的表设计")]),v._v(" "),t("p",[v._v("范式一共6层,但是数据库的设计通常只要求满足三层即可,因为范式层数越高,冗余度越低,但是查询效率也越低")]),v._v(" "),t("h3",{attrs:{id:"第一范式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#第一范式"}},[v._v("#")]),v._v(" 第一范式")]),v._v(" "),t("blockquote",[t("p",[v._v("概念 第一范式:1NF,数据字段设计时必须满足"),t("strong",[v._v("原子性")])])]),v._v(" "),t("ul",[t("li",[v._v("1NF 要求字段数据是不需要拆分就可以直接应用")]),v._v(" "),t("li",[v._v("如果数据使用的时候需要进行拆分那么就违背1NF")])]),v._v(" "),t("p",[v._v("1、设计的字段是否在使用的时候还需要再拆分?")]),v._v(" "),t("p",[v._v("2、将数据拆分到最小单位(使用),然后设计成字段")]),v._v(" "),t("p",[v._v("3、满足1NF")]),v._v(" "),t("h3",{attrs:{id:"第二范式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#第二范式"}},[v._v("#")]),v._v(" 第二范式")]),v._v(" "),t("blockquote",[t("p",[v._v("概念:第二范式:2NF,字段设计不能存在 "),t("strong",[v._v("部分依赖")])])]),v._v(" "),t("ul",[t("li",[v._v("部分依赖:首先表存在复合主键,其次有的字段不是依赖整个主键,而只是依赖主键中的部分")]),v._v(" "),t("li",[v._v("部分依赖解决:让所有非主属性都依赖一个候选关键字\n"),t("ul",[t("li",[v._v("最简单方式:取消复合主键(一般选用逻辑主键替代,但是本质依然是复合主键做主),所有非主属性都\n依赖主属性(逻辑主键)")]),v._v(" "),t("li",[v._v("正确方式:将部分依赖关系独立成表")])])])]),v._v(" "),t("h3",{attrs:{id:"第三范式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#第三范式"}},[v._v("#")]),v._v(" 第三范式")]),v._v(" "),t("blockquote",[t("p",[v._v("概念:第三范式:3NF,字段设计不能存在"),t("strong",[v._v("传递依赖")])])]),v._v(" "),t("ul",[t("li",[t("p",[v._v("传递依赖:字段某个非主属性不直接依赖主属性,而是通过依赖某个其他非主属性而传递到主属性之上")])]),v._v(" "),t("li",[t("p",[v._v("传递依赖解决:让依赖非主属性的字段与依赖字段独立成表")])])]),v._v(" "),t("h3",{attrs:{id:"逆规范化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#逆规范化"}},[v._v("#")]),v._v(" 逆规范化")]),v._v(" "),t("p",[v._v("逆规范化:为了提升数据查询的效率而刻意违背范式的规则")]),v._v(" "),t("ul",[t("li",[v._v("逆规范化的目标是为了提升数据访问效率")]),v._v(" "),t("li",[v._v("所谓逆规范化就是减少表之间的关联查询(效率降低),刻意增加数据冗余")])]),v._v(" "),t("ol",[t("li",[v._v("表中部分数据来源于其他表(通常只需要其他表的某个简单数据)")]),v._v(" "),t("li",[v._v("当前表会被高频次查询")]),v._v(" "),t("li",[v._v("数据表数据量很大")]),v._v(" "),t("li",[v._v("考虑使用逆规范化")])]),v._v(" "),t("blockquote",[t("p",[v._v("注意")])]),v._v(" "),t("ul",[t("li",[v._v("逆规范化只有在数据量大,查询效率低下的时候为了提升査询效率而牺牲磁盘空间的种做法")]),v._v(" "),t("li",[v._v("逆规范化后数据表的设计必然是不完全符合范式要求的(2NF/3NF)")])]),v._v(" "),t("h3",{attrs:{id:"总结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[v._v("#")]),v._v(" 总结")]),v._v(" "),t("p",[v._v("1、范式是关系型数据库设计借鉴用来減少数据冗余的")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("1NF : 数据字段的原子性, 增强数据的可用性")])]),v._v(" "),t("li",[t("p",[v._v("2NF : 取消字段的部分依赖,建立数据的关联性, 减少数据冗余")])]),v._v(" "),t("li",[t("p",[v._v("3NF : 取消字段的传递依赖,将相关实体独立划分, 减少数据冗余")])]),v._v(" "),t("li",[t("p",[v._v("逆规范化 : 为了提升数据访问效率, 刻意增加数据冗余(磁盘空间利用率与访问效率的矛盾)")])])]),v._v(" "),t("p",[v._v("2、在进行数据表设计的时候,需要严格遵循范式规范")]),v._v(" "),t("ul",[t("li",[v._v("基于规范设计数据表")]),v._v(" "),t("li",[v._v("在设计表中深入认知范式规范")]),v._v(" "),t("li",[v._v("熟练的基于业务设计数据表")])]),v._v(" "),t("h2",{attrs:{id:"表关系"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#表关系"}},[v._v("#")]),v._v(" 表关系")]),v._v(" "),t("h3",{attrs:{id:"一对一"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#一对一"}},[v._v("#")]),v._v(" 一对一")]),v._v(" "),t("p",[v._v("概念")]),v._v(" "),t("ul",[t("li",[v._v("一对一关系:一张表中的一条记录与另外一张表中有且仅有一条记录有关系I")]),v._v(" "),t("li",[v._v("一对一关系通常是用来将一张原本就是一体的表拆分成两张表\n"),t("ul",[t("li",[v._v("频繁使用部分:常用字段")]),v._v(" "),t("li",[v._v("不常使用部分:生僻字段")]),v._v(" "),t("li",[v._v("使用相同的主键对应")])])]),v._v(" "),t("li",[v._v("一对一关系设计较多使用在优化方面")])]),v._v(" "),t("h3",{attrs:{id:"一对多"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#一对多"}},[v._v("#")]),v._v(" 一对多")]),v._v(" "),t("p",[t("strong",[v._v("一对多关系")]),v._v(":也叫多对一关系,一张表中的一条记录与另外一张表的多条记录对应,反过来另外一张表的多条记录\n只能对应当前表的一条记录")]),v._v(" "),t("ul",[t("li",[v._v("一对多关系是实体中非常常见的种关系,实体设计时也应用非常多")]),v._v(" "),t("li",[v._v("一对多关系的核心解决方案是如何让记录能够正确匹配到另外表中的数据\n"),t("ul",[t("li",[v._v("一表设计:一表记录在另外一张表中有多条记录,所以无法记录多个字段(违背1NF)")]),v._v(" "),t("li",[v._v("多表设计:多表记录在另外一张表中只有一条记录,可以设置字段记录对应的主属性(通常主键)")])])])]),v._v(" "),t("h3",{attrs:{id:"多对多关系"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#多对多关系"}},[v._v("#")]),v._v(" 多对多关系")]),v._v(" "),t("p",[t("strong",[v._v("多对多关系")]),v._v(":一张表中的一条记录对应另外一个表中多条记录,反过来一样")]),v._v(" "),t("ul",[t("li",[v._v("多对多关系在实体中是最常见的关系")]),v._v(" "),t("li",[v._v("多对多关系是无法在自身表中维护对应表关系的(违背1NF),需要通过第三方表来实现将多对多关系变成多\n个多对一关系\n"),t("ul",[t("li",[v._v("设计一个中间表:记录两张表之间的对应关系(主属性)")]),v._v(" "),t("li",[v._v("中间表与其他表都是多对一的关系")])])])]),v._v(" "),t("h3",{attrs:{id:"总结-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#总结-2"}},[v._v("#")]),v._v(" 总结")]),v._v(" "),t("ol",[t("li",[v._v("表关系的设计是要遵循范式规范作为前提")]),v._v(" "),t("li",[v._v("表关系的设计是根据实体关系以及业务需求进行设计\n"),t("ul",[t("li",[v._v("一对一关系:主要在于优化访问效率、传输效率")]),v._v(" "),t("li",[v._v("对多关系:在于如何让实体间的联系在结构中体现(后期可以使用外键外键行相关约朿保证数据的有效性)")]),v._v(" "),t("li",[v._v("多对多关系:与一对多关系一样,清晰明了的体现实体间的结构联系")])])]),v._v(" "),t("li",[v._v("在设计数据库的时候,要严格使用表关系来进行实体关联设计\n"),t("ul",[t("li",[v._v("基于表关系来实现实体间的关联控制")]),v._v(" "),t("li",[v._v("在设计和应用表的时候提炼对表关系的认知")]),v._v(" "),t("li",[v._v("能够熟练的基于业务控制数据库的关系")])])])])])}),[],!1,null,null,null);_.default=l.exports}}]);