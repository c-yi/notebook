(window.webpackJsonp=window.webpackJsonp||[]).push([[137],{516:function(t,s,n){"use strict";n.r(s);var a=n(23),e=Object(a.a)({},(function(){var t=this,s=t.$createElement,n=t._self._c||s;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"var-let-const"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#var-let-const"}},[t._v("#")]),t._v(" var let const")]),t._v(" "),n("p",[t._v("我们就从声明过程，内存分配，和变量提升这三点来看这三者之间的区别。")]),t._v(" "),n("h2",{attrs:{id:"声明过程"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#声明过程"}},[t._v("#")]),t._v(" 声明过程")]),t._v(" "),n("p",[n("strong",[t._v("var:")]),t._v(" 遇到有var的作用域，在任何语句执行前都已经完成了声明和初始化，也就是变量提升而且拿到undefined的原因由来"),n("br"),t._v(" "),n("strong",[t._v("function:")]),t._v(" 声明、初始化、赋值一开始就全部完成，所以函数的变量提升优先级更高"),n("br"),t._v(" "),n("strong",[t._v("let:")]),t._v(" 解析器进入一个块级作用域，发现let关键字，变量只是先完成声明，并没有到初始化那一步。此时如果在此作用域提前访问，则报错"),n("code",[t._v("xx is not defined")]),t._v("\n这就是暂时性死区的由来。等到解析到有let那一行的时候，才会进入初始化阶段。如果let的那一行是赋值操作，则初始化和赋值同时进行"),n("br"),t._v("\nconst,class都是同let一样的道理 比如解析如下代码步骤：")]),t._v(" "),n("div",{staticClass:"language-javascript line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-javascript"}},[n("code",[n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("   "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 没用的第一行 ")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 没用的第二行")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 如果此时访问a报错 a is not defined let a = 1 ")]),t._v("\n    console"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("a"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" \n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" \n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/*\n步骤： \n发现作用域有let a，先注册个a，仅仅注册 \n没用的第一行 没用的第二行 \na is not defined，暂时性死区的表现 假设前面那行不报错，\na初始化为undefined a赋值为1 对比于var，let、const只是解耦了声明和初始化的过程，\nvar是在任何语句执行前都已经完成了声明和初始化，let、const仅仅是在任何语句执行前只完成了声明。*/")]),t._v("\n")])]),t._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[t._v("1")]),n("br"),n("span",{staticClass:"line-number"},[t._v("2")]),n("br"),n("span",{staticClass:"line-number"},[t._v("3")]),n("br"),n("span",{staticClass:"line-number"},[t._v("4")]),n("br"),n("span",{staticClass:"line-number"},[t._v("5")]),n("br"),n("span",{staticClass:"line-number"},[t._v("6")]),n("br"),n("span",{staticClass:"line-number"},[t._v("7")]),n("br"),n("span",{staticClass:"line-number"},[t._v("8")]),n("br"),n("span",{staticClass:"line-number"},[t._v("9")]),n("br"),n("span",{staticClass:"line-number"},[t._v("10")]),n("br"),n("span",{staticClass:"line-number"},[t._v("11")]),n("br"),n("span",{staticClass:"line-number"},[t._v("12")]),n("br")])]),n("h2",{attrs:{id:"内存分配"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#内存分配"}},[t._v("#")]),t._v(" 内存分配")]),t._v(" "),n("p",[n("strong",[t._v("var:")]),t._v(" 会直接在栈内存里预分配内存空间，然后等到实际语句执行的时候，再存储对应的变量，\n如果传的是引用类型，那么会在堆内存里开辟一个内存空间存储实际内容，栈内存会存储一个指向堆内存的指针"),n("br"),t._v(" "),n("strong",[t._v("let:")]),t._v(" 是不会在栈内存里预分配内存空间，而且在栈内存分配变量时，做一个检查，如果已经有相同变量名存在就会报错"),n("br"),t._v(" "),n("strong",[t._v("const:")]),t._v(" 也不会预分配内存空间，在栈内存分配变量时也会做同样的检查。不过const存储的变量是不可修改的，对于基本类型来说你无法修改定义的值，\n对于引用类型来说你无法修改栈内存里分配的指针，但是你可以修改指针指向的对象里面的属性")]),t._v(" "),n("h2",{attrs:{id:"变量提升"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#变量提升"}},[t._v("#")]),t._v(" 变量提升")]),t._v(" "),n("p",[n("strong",[t._v("let const 和var三者其实会存在变量提升")]),n("br"),t._v("\nlet 只是创建过程提升，初始化过程并没有提升，所以会产生暂时性死区。"),n("br"),t._v("\nvar 的创建和初始化过程都提升了，所以在赋值前访问会得到undefined"),n("br"),t._v("\nfunction 的创建、初始化、赋值都被提升了")])])}),[],!1,null,null,null);s.default=e.exports}}]);