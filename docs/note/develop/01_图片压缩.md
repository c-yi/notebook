# 图片

## picture 标签
> 做媒体查询,然后使用合适的图片渲染,  
source中的资源将作为 img 的 src, 如果不匹配,将img中的src 作为默认选项

```html
<picture>
  <source media="(min-width: 650px)" srcset="img_pink_flowers.jpg">
  <source media="(min-width: 465px)" srcset="img_white_flower.jpg">
  <img src="img_orange_flowers.jpg" alt="Flowers" style="width:auto;">
</picture>
```



## file转base64
```js
fillFile=() =>{
    let files = this.$refs.imgList.files;
    console.log(files);
    Array.from(files).forEach(file => {
        const reader = new FileReader();
        const {size, name, type} = file;
        reader.readAsDataURL(file);
        reader.onload = () => {
            const item = {size, name, type, src: reader.result};
            this.source.push(item);
            this.drawImage(item)
        }
    })
}
```
## canvas 绘图
```js
drawImage =(data)=> {
    const {src: dataURI, name, type} = data;
        let img = new Image();   // 创建一个<img>元素
        img.src = dataURI; // 设置图片源地址
        // 只能在onload中获取图片的尺寸,不然可能得到的是 0
        img.onload = () => {
            const canvas = document.createElement('canvas');
            const {w, h} = this.getZoom(img);
            // 按照缩放比例显示图片
            canvas.width = w;
            canvas.height = h;
            let ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0, w, h);
            // 对图片进行压缩
            let newDataURI = canvas.toDataURL(type || 'image/png', 0.8);
            document.getElementById('canvas').appendChild(canvas);
            this.download(newDataURI, name, type)
        }
    }
```
## 按比例缩放
```js
getZoom=(img)=> {
    const {width: w, height: h} = img;// 原始宽高
    const {canvas_w: c_w, canvas_h: c_h} = this.canvasProp;//默认宽高
    let targetWidth = w, targetHeight = h;// 如果图片没有超多设定阀值,就按照原大小
    if (w > c_w || h > c_h) {
        if (w / h > c_w / c_h) {
            // 更宽，按照宽度限定尺寸
            targetWidth = c_w;
            targetHeight = Math.round(c_w * (h / w));
        } else {
            targetHeight = c_h;
            targetWidth = Math.round(c_h * (w / h));
        }
    }
    return {w: targetWidth, h: targetHeight}
}
```
## base64 转 blob
```js
b64ToBlob=(dataURI, type) =>{
        let byteString = atob(dataURI.split(',')[1]);
        let ab = new ArrayBuffer(byteString.length);
        let ia = new Uint8Array(ab);
        for (let i = 0; i < byteString.length; i++) {
            ia[i] = byteString.charCodeAt(i);
        }
        return new Blob([ab], {type: type || 'image/jpeg'});
    }
```
## 下载
```js
download =(newDataURI, fileName, type)=> {
    let a = document.createElement('a');
    a.href = newDataURI;
    a.download = fileName;
    const newBlob = this.b64ToBlob(newDataURI, type);
    a.textContent = '下载' + formate(newBlob.size);
    document.getElementById('canvas').appendChild(a)
}
```
## 图片预览/压缩/上传  <Badge text="示例" vertical="middle" type="tip"/> 

> 前端的图片压缩主要是依靠 canvas 来完成

<PerformanceImg/>

<ShowCode>
<<< @/docs/.vuepress/components/PerformanceImg.vue
</ShowCode>
