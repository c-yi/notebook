# var let const
我们就从声明过程，内存分配，和变量提升这三点来看这三者之间的区别。

## 声明过程   
**var:** 遇到有var的作用域，在任何语句执行前都已经完成了声明和初始化，也就是变量提升而且拿到undefined的原因由来   
**function:** 声明、初始化、赋值一开始就全部完成，所以函数的变量提升优先级更高  
**let:** 解析器进入一个块级作用域，发现let关键字，变量只是先完成声明，并没有到初始化那一步。此时如果在此作用域提前访问，则报错`xx is not defined`
这就是暂时性死区的由来。等到解析到有let那一行的时候，才会进入初始化阶段。如果let的那一行是赋值操作，则初始化和赋值同时进行   
const,class都是同let一样的道理 比如解析如下代码步骤：
```javascript
{   // 没用的第一行 
    // 没用的第二行
    // 如果此时访问a报错 a is not defined let a = 1 
    console.log(a) 
} 
/*
步骤： 
发现作用域有let a，先注册个a，仅仅注册 
没用的第一行 没用的第二行 
a is not defined，暂时性死区的表现 假设前面那行不报错，
a初始化为undefined a赋值为1 对比于var，let、const只是解耦了声明和初始化的过程，
var是在任何语句执行前都已经完成了声明和初始化，let、const仅仅是在任何语句执行前只完成了声明。*/
```


## 内存分配 
**var:** 会直接在栈内存里预分配内存空间，然后等到实际语句执行的时候，再存储对应的变量，
如果传的是引用类型，那么会在堆内存里开辟一个内存空间存储实际内容，栈内存会存储一个指向堆内存的指针  
**let:** 是不会在栈内存里预分配内存空间，而且在栈内存分配变量时，做一个检查，如果已经有相同变量名存在就会报错  
**const:** 也不会预分配内存空间，在栈内存分配变量时也会做同样的检查。不过const存储的变量是不可修改的，对于基本类型来说你无法修改定义的值，
对于引用类型来说你无法修改栈内存里分配的指针，但是你可以修改指针指向的对象里面的属性

## 变量提升 
**let const 和var三者其实会存在变量提升**  
let 只是创建过程提升，初始化过程并没有提升，所以会产生暂时性死区。   
var 的创建和初始化过程都提升了，所以在赋值前访问会得到undefined   
function 的创建、初始化、赋值都被提升了  
